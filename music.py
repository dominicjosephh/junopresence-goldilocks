import os
import requests
from datetime import datetime
from typing import List, Dict, Optional

SPOTIFY_API_BASE = "https://api.spotify.com/v1"

def _spotify_headers(token: str) -> dict:
    return {"Authorization": f"Bearer {token}"}

def handle_music_command(command: str, spotify_token: str = "") -> dict:
    # Basic parser for music-related commands
    cmd = command.strip().lower()
    if "play" in cmd and spotify_token:
        # You could expand this to search and play a track using Spotify API
        return {"message": "Play command received (not fully implemented)", "command": command}
    elif "pause" in cmd and spotify_token:
        # Spotify pause endpoint
        requests.put(f"{SPOTIFY_API_BASE}/me/player/pause", headers=_spotify_headers(spotify_token))
        return {"message": "Paused playback"}
    elif "next" in cmd and spotify_token:
        requests.post(f"{SPOTIFY_API_BASE}/me/player/next", headers=_spotify_headers(spotify_token))
        return {"message": "Skipped to next track"}
    elif "previous" in cmd and spotify_token:
        requests.post(f"{SPOTIFY_API_BASE}/me/player/previous", headers=_spotify_headers(spotify_token))
        return {"message": "Went to previous track"}
    return {"message": "Unknown or unimplemented command", "command": command}

def create_playlist(playlist_name: str, context: str, spotify_token: str) -> dict:
    # Create a playlist for the current user
    user_resp = requests.get(f"{SPOTIFY_API_BASE}/me", headers=_spotify_headers(spotify_token))
    if user_resp.status_code != 200:
        return {"error": "Could not get user profile"}
    user_id = user_resp.json().get("id")
    payload = {
        "name": playlist_name,
        "description": f"Playlist generated by Juno for context: {context}",
        "public": False
    }
    pl_resp = requests.post(f"{SPOTIFY_API_BASE}/users/{user_id}/playlists", headers=_spotify_headers(spotify_token), json=payload)
    if pl_resp.status_code == 201:
        return {"playlist": pl_resp.json()}
    else:
        return {"error": pl_resp.text}

def get_music_recommendations(context: str, spotify_token: Optional[str] = None) -> list:
    # Simple: recommend tracks based on a context (could be genre, mood, etc.)
    if not spotify_token:
        return []
    # Example: use Spotify recommendations endpoint (expand as needed)
    params = {
        "limit": 10,
        "seed_genres": context if context else "pop"
    }
    rec_resp = requests.get(f"{SPOTIFY_API_BASE}/recommendations", headers=_spotify_headers(spotify_token), params=params)
    if rec_resp.status_code == 200:
        tracks = rec_resp.json().get("tracks", [])
        return [{"name": t["name"], "artist": t["artists"][0]["name"], "uri": t["uri"]} for t in tracks]
    return []

def get_music_insights() -> dict:
    # Expand with real analytics if you log user music history
    return {
        "total_tracks_played": 0,
        "favorite_genres": [],
        "favorite_artists": [],
        "recent_tracks": []
    }

def log_current_track(spotify_token: str, context: str = "general"):
    # Optionally, log the user's currently playing track for memory/analytics
    current_resp = requests.get(f"{SPOTIFY_API_BASE}/me/player/currently-playing", headers=_spotify_headers(spotify_token))
    if current_resp.status_code == 200:
        track = current_resp.json().get("item", {})
        # Optionally, log to a DB file or memory system for user analytics
        print(f"Logging track: {track.get('name')} | Artist: {track.get('artists',[{}])[0].get('name')}, Context: {context}, Time: {datetime.utcnow().isoformat()}")
    return
